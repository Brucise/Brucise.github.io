{"meta":{"title":"蜗牛壳","subtitle":null,"description":null,"author":"ChenHuang","url":"http://yoursite.com"},"pages":[{"title":"李辛格传","date":"2018-07-08T03:38:08.000Z","updated":"2019-03-09T09:34:10.726Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"简介黄晨，号李辛格。尘世中一个迷途小码农。 工作 时间 公司 岗位 2018.03 ~ 至今 携程旅行网机票BU java工程师 实习 时间 公司 岗位 2017.8 ~ 2018.03 携程旅行网机票BU java工程师 2016.06 ~ 2017.02 英特尔亚太研发有限公司 自动化测试工程师 教育 时间 学校 专业 学历 2015.09 ~ 2018.03 华东师范大学 电子与通信工程 硕士 2011.09 ~ 2015.06 南昌大学 应用物理学 本科"},{"title":"标签","date":"2018-07-08T03:38:08.000Z","updated":"2019-03-06T11:40:58.574Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"springboot启动流程分析","slug":"springboot","date":"2019-03-21T05:34:40.000Z","updated":"2019-03-21T07:53:02.130Z","comments":true,"path":"2019/03/21/springboot/","link":"","permalink":"http://yoursite.com/2019/03/21/springboot/","excerpt":"","text":"代码部分1234567891011121314151617public class Application extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; try &#123; ConfigurableApplicationContext context = new SpringApplicationBuilder(Application.class).run(args); int port = context.getEnvironment().getProperty(\"server.port\", int.class); System.setProperty(\"java.awt.headless\", \"false\"); Desktop.getDesktop().browse(new URI(\"http://127.0.0.1:\" + port + \"/api\")); &#125; catch (Exception ex) &#123; I_LOG.error(\"Application Main Exception : \" + ex.getMessage(), ex); &#125; &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Application.class); &#125; 首先，自己的类要继承自SpringBootServletInitializer，如果是war包启动，要复写configure方法。 分析 SpringBootServletInitializer源码SpringBootServletInitializer实现了WebApplicationInitializer接口，WebApplicationInitializer只有一个onStartup方法。再看到WebApplicationInitializer同级目录下有个SpringServletContainerInitializer。实现如下： 123456789101112131415161718192021222324252627282930313233343536@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;(); if (webAppInitializerClasses != null) &#123; for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; try &#123; initializers.add((WebApplicationInitializer) waiClass.newInstance()); &#125; catch (Throwable ex) &#123; throw new ServletException(\"Failed to instantiate WebApplicationInitializer class\", ex); &#125; &#125; &#125; &#125; if (initializers.isEmpty()) &#123; servletContext.log(\"No Spring WebApplicationInitializer types detected on classpath\"); return; &#125; servletContext.log(initializers.size() + \" Spring WebApplicationInitializers detected on classpath\"); AnnotationAwareOrderComparator.sort(initializers); for (WebApplicationInitializer initializer : initializers) &#123; initializer.onStartup(servletContext); &#125; &#125;&#125; 先判断webAppInitializerClasses（set）是否为空，不为空的话遍历，不是接口、抽象类、并且是WebApplicationInitializer的实现，则将其实例化后加到initializers（LinkedList）中，通过某种方式给initializers排序，排序后调用其onStartup方法。那SpringServletContainerInitializer又在何处被调用？SpringServletContainerInitializer实现了ServletContainerInitializer，而它可以通过SPI机制，当启动web容器的时候，会自动到添加的相应jar包下找到META-INF/services下以ServletContainerInitializer的全路径名称命名的文件，它的内容为ServletContainerInitializer实现类的全路径，将它们实例化。","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"QuickSort","slug":"QuickSort","date":"2019-03-20T07:19:36.000Z","updated":"2019-03-20T07:41:23.785Z","comments":true,"path":"2019/03/20/QuickSort/","link":"","permalink":"http://yoursite.com/2019/03/20/QuickSort/","excerpt":"","text":"介绍特征 时间复杂度是O(n*logn) 不稳定 递归三要素参数、终止条件、返回值123456789101112131415161718192021222324252627private void help(int[] array, int left, int right) &#123; if (left &gt;= right) &#123; // 终止条件 return; &#125; int n = partition(array, left, right); // 切分 help(array, left, n - 1); //将左半部分排序 help(array, n + 1, right); //将右半部分排序 &#125; private int partition(int[] array, int left, int right) &#123; int v = array[left]; while (true) &#123; while (v &gt; array[left]) &#123; left++; &#125; while (v &lt; array[right]) &#123; right--; &#125; if (left &gt;= right) &#123; break; &#125; int tmp = array[left]; array[left] = array[right]; array[right] = tmp; &#125; return left; &#125;","categories":[],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"Longest Palindromic Substring","slug":"2019-03-08Longest-Palindromic-Substring","date":"2019-03-08T10:07:12.000Z","updated":"2019-03-09T10:27:37.674Z","comments":true,"path":"2019/03/08/2019-03-08Longest-Palindromic-Substring/","link":"","permalink":"http://yoursite.com/2019/03/08/2019-03-08Longest-Palindromic-Substring/","excerpt":"","text":"Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.给定一个字符串s，找出其中的最大回文子串，假定字符串s最长为1000. 前言这是一道leetcode上的字符串题目，下图是我提交的几种解法的耗时与内存，在通过的几种里，8ms和111ms是网上的解法，186ms和576ms是我自己的解法。我的两种解法的思路都一样，将对称中心设为单个字符（“a”）或相等的双字符（“aa”），然后分别向两边扩展，最开始耗时太久是因为每次我都是new了一个字符数组，后来改成直接在字符串上进行charat操作。这样直接将时间降为186ms。通过观察发现，8毫秒的解法与我的解法，思路一致，但是代码更为简洁。全程都是操作下标int类型，而我一开始就使用了substring操作。经过改正，我也使用下标int进行操作，时间降为10毫秒。注意： 字符串尽量用下标进行操作，尽量少调用substring。 少去定义新的游标，尽量跟遍历时的i联系起来。10ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package longestpalindrome;/** * @author: chenhuang * @date: 2019/3/9 * @description: */public class SolutionV3 &#123; public static void main(String[] args) &#123; SolutionV3 solution = new SolutionV3(); System.out.println(solution.longestPalindrome(\"vv\")); &#125; public String longestPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return \"\"; &#125; int start, end; start = 0; end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = longHelp(s, i, i); if (len1 &gt; end - start) &#123; start = i - (len1 - 1) / 2; end = i + len1 / 2; &#125; if (s.length() &gt;= 2 &amp;&amp; findTwins(s, i)) &#123; int len2 = longHelp(s, i, i + 1); if (len2 &gt; end - start) &#123; start = i - (len2 - 1) / 2; end = i + len2 / 2; &#125; &#125; &#125; return s.substring(start, end + 1); &#125; private int longHelp(String s, int x, int y) &#123; while (x &gt;= 0 &amp;&amp; y &lt; s.length() &amp;&amp; s.charAt(x) == s.charAt(y)) &#123; x--; y++; &#125; return y - x - 1; &#125; private boolean findTwins(String s, int index) &#123; for (int i = index; i &lt; s.length() - 1; i++) &#123; if (s.charAt(i) == s.charAt(i + 1)) &#123; return true; &#125; &#125; return false; &#125;&#125; 576ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package longestpalindrome;public class Solution &#123; public static void main(String[] args) &#123; Solution solution = new Solution(); //576ms解法 System.out.println(solution.longestPalindrome(\"cbbd\")); &#125; public String longestPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return \"\"; &#125; char[] arr = s.toCharArray(); char[] arrInterval = new char[s.length() * 2 + 1]; for (int i = 0; i &lt; arrInterval.length; i++) &#123; arrInterval[i] = ' '; &#125; for (int i = 0; i &lt; s.length(); i++) &#123; arrInterval[2 * i + 1] = arr[i]; &#125; return longestPalindromeHelp(arrInterval); &#125; private String longestPalindromeHelp(char[] arr) &#123; String longgest = String.valueOf(arr[1]); for (int i = 2; i &lt; arr.length; i++) &#123; char[] result = new char[arr.length]; int p, q; p = i - (1 + i % 2); q = i + (1 + i % 2); while (p &gt; 0 &amp;&amp; q &lt; arr.length) &#123; if (arr[p] != arr[q]) &#123; break; &#125; result[i] = arr[i]; result[p] = result[q] = arr[p]; p = p - 2; q = q + 2; &#125; String current = String.valueOf(result).trim().replaceAll(\"[^0-9a-zA-Z]\", \"\"); if (longgest.length() &lt;= current.length()) &#123; longgest = current; &#125; &#125; return longgest; &#125;&#125; 186ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 package longestpalindrome;public class Solution &#123; public static void main(String[] args) &#123; Solution solution = new Solution(); System.out.println(solution.longestPalindrome(\"aaaa\")); &#125; public String longestPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return \"\"; &#125; int p, q; StringBuilder stringBuilder = new StringBuilder(s); CharSequence longsub = new StringBuilder(s.substring(0, 1)); for (int i = 0; i &lt; stringBuilder.length(); i++) &#123; p = q = i; CharSequence s1 = longHelp(stringBuilder, p, q); if (s1.length() &gt; longsub.length()) &#123; longsub = s1; &#125; if (s.length() &gt;= 2 &amp;&amp; findTwins(s, i)) &#123; p = i; q = i + 1; CharSequence s2 = longHelp(stringBuilder, p, q); if (s2.length() &gt; longsub.length()) &#123; longsub = s2; &#125; &#125; &#125; return longsub.toString(); &#125; private CharSequence longHelp(StringBuilder s, int x, int y) &#123; int maxsub, left, right; maxsub = 1; CharSequence charSequence = s.subSequence(0, 1); while (x &gt;= 0 &amp;&amp; y &lt; s.length() &amp;&amp; s.charAt(x) == s.charAt(y)) &#123; int cur = y - x + 1; left = x; right = y; x--; y++; if (cur &gt; maxsub) &#123; maxsub = cur; charSequence = s.subSequence(left, right + 1); &#125; &#125; return charSequence; &#125; private boolean findTwins(String s, int index) &#123; for (int i = index; i &lt; s.length() - 1; i++) &#123; if (s.charAt(i) == s.charAt(i + 1)) &#123; return true; &#125; &#125; return false; &#125;&#125; 8ms12345678910111213141516171819202122232425class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return \"\"; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125;private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1;&#125;&#125; 111ms12345678910111213141516171819202122class Solution &#123; public String longestPalindrome(String s) &#123; String res = \"\"; int start, end; for(int i = 0; i&lt;s.length(); i++)&#123; for(int j = 0; j&lt;=i; j++)&#123; start = j; end = i; if((i-j+1)&gt;res.length())&#123; while(s.charAt(start)==s.charAt(end))&#123; if(start == end || (end-start)==1)&#123; res = s.substring(j, i+1); break; &#125; start ++; end --; &#125; &#125; &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"jmockito","slug":"jmockito","date":"2019-03-07T11:01:00.000Z","updated":"2019-03-07T12:03:31.403Z","comments":true,"path":"2019/03/07/jmockito/","link":"","permalink":"http://yoursite.com/2019/03/07/jmockito/","excerpt":"","text":"前言最近换到了新组，增值-交叉BU，主要的业务就是机票完成页上售卖一些X产品，我是写服务端的，然后jenkins上单元测试覆盖率有点低，目前branch的覆盖率在百分之十四，而目标是在四月一号前达到百分之五十。所以最近接触的单测工具有点多，用过的几款有：powermock、mockito、jmockito。而powermock跟jenkins上的jacoco不兼容，mockito无法mock私有方法，jmokito成功提升了单测覆盖率。在这里总结一下jmockito的使用方法。 简介jmockito网站jmokito可以用来mock静态方法，类内部的私有方法、私有变量以及引用的其他类的方法。这里就不讲怎么引用maven包，直接上手用了。 几个概念CUT(code under test)被测试代码 mock和stubmock是基于“行为”的测试，主要测试cut和被依赖着之间的相互调用；stub是基于“状态”的测试，主要测试CUT和被依赖者内部数据的状态。JMockit有两套API，mock API用来进行mock测试；mock-up API用来进行stub测试。 API用法@Mocked加上了JMockit的API @Mocked, JMockit会实例化这个对象Mocked可以用来修饰类、接口和抽象类，返回默认值（如果是原始类型，返回原始值的默认值，如果为其他对象，则返回一个同样被Mocked的对象）Mocked十分粗暴，会mock掉整个的实现 @Injectable@Injectable功能跟@Mocked相似，区别是@Injectable只针对修饰的实例，对mock类的静态方法、构造函数没有影响 @Tested@Tested表示被测试对象。如果该对象没有赋值，JMockit会去实例化它，若@Tested的构造函数有参数，则JMockit通过在测试属性&amp;测试参数中查找@Injectable修饰的Mocked对象注入@Tested对象的构造函数来实例化，不然，则用无参构造函数来实例化。除了构造函数的注入，JMockit还会通过属性查找的方式，把@Injectable对象注入到@Tested对象中。注入的匹配规则：先类型，再名称(构造函数参数名，类的属性名)。若找到多个可以注入的@Injectable，则选择最优先定义的@Injectable对象 @Capturing@Capturing主要用于子类/实现类的Mock，比如java动态代理生成的类，这些类没有名字，无法进行正常的mock当只知道父类或接口时，但需要控制其子类的行为时，子类可能有多个实现（可能有人工写的，也可能是AOP代理自动生成时），需要使用@Capturing ExpectationsRecord对象的核心方法，最核心和重要的注解了，可以和引用外部类的Mock对象(@Injectabe,@Mocked,@Capturing)来录制，也可以通过构建函数注入类/对象来录制限制：不能mock对象的native方法和private方法 MockUp &amp; MockMockUp &amp; @Mock提供更改代码行为的Mock方式，最强大mock实现，主要有以下限制： 无法mock单个实例 无法mock动态代理对象 对类的所有方法都进行Mock，书写MockUp的代码量太大，可以用于项目中比较通用模块，减少大量重复的Exceptations VerificationsVerifications是用于做验证，过程式编程的福音，验证Mock对象（即@Moked/@Injectable@Capturing修饰的或传入Expectation构造函数的对象)有没有调用过某方法，调用了多少次主要用于一些没有返回值的代码验证 使用流程recoed(录制)--&gt;replay(回放)--&gt;verify(验证) 假设下面这个类是要测试的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.ctrip.flight.mobile.fio.core.xrecommend.card;import com.alibaba.fastjson.JSON;import com.ctrip.flight.mobile.fio.common.qconfig.factory.QConfigManager;import com.ctrip.flight.mobile.fio.core.xrecommend.constant.CardExtraType;import com.ctrip.flight.mobile.fio.core.xrecommend.context.AdContext;import com.ctrip.flight.mobile.fio.core.xrecommend.service.adbannerservice.AdBannerModelTransfer;import com.ctrip.flight.mobile.fio.core.xrecommend.service.adbannerservice.customize.CustomizeAdBannerService;import com.ctrip.flight.mobile.fio.model.pojo.adbanner.FlightCompleteAdBannerConfigPojo;import com.ctrip.flight.mobile.fio.model.pojo.adbanner.FlightCompleteBannerImgItemDTO;import com.ctrip.flight.mobile.fio.model.pojo.visitorinfo.VisitorInfo;import com.ctrip.model.flight.wireless.fio.ad.v1.entity.FlightMarketCardInformationType;import com.ctrip.model.flight.wireless.fio.ad.v1.entity.FlightXProductExtendInformationType;import com.ctriposs.baiji.rpc.mobile.common.types.MobileRequestHead;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.List;@Service(\"AdBannerRecommend\")public class AdBannerRecommend extends AbstractRecommend &#123; private AdBannerModelTransfer adBannerModelTransfer; private CustomizeAdBannerService customizeAdBannerService; private QConfigManager qConfigManager; @Autowired public AdBannerRecommend(AdBannerModelTransfer adBannerModelTransfer, CustomizeAdBannerService customizeAdBannerService) &#123; this.adBannerModelTransfer = adBannerModelTransfer; this.customizeAdBannerService = customizeAdBannerService; &#125; @Override public List&lt;FlightMarketCardInformationType&gt; getMarketCards(VisitorInfo visitor, MobileRequestHead head, AdContext adContext) &#123; qConfigManager = adContext.getqConfigManager(); return getResult(adContext); &#125; public List&lt;FlightMarketCardInformationType&gt; getResult(AdContext adContext) &#123; // 获得广告横幅卡片，productType=15 List&lt;FlightMarketCardInformationType&gt; cards = new ArrayList&lt;&gt;(); FlightMarketCardInformationType card = qConfigManager.getAdBannerCard(); // 设置广告横幅的扩展信息，EXTRA_TYPE=18 List&lt;FlightXProductExtendInformationType&gt; extas = new ArrayList&lt;&gt;(); FlightXProductExtendInformationType exta = new FlightXProductExtendInformationType(); exta.setExtentType(CardExtraType.EXTRA_TYPE_18); exta.setContent(buildCard(adContext)); extas.add(exta); if (card != null) &#123; card.setExtendInfo(extas); cards.add(card); &#125; return cards; &#125; private String buildCard(AdContext adContext) &#123; // 从qconfig获得广告位配置，[] List&lt;FlightCompleteAdBannerConfigPojo&gt; banners = qConfigManager.getAdBanners(); List&lt;FlightCompleteBannerImgItemDTO&gt; bs = adBannerModelTransfer.transfer(banners); // 添加所有的自定义广告banner bs.addAll(buildCustomizeAdBanners(adContext.getVisitorInfo(), adContext)); return JSON.toJSONString(bs); &#125; /** * 大配置版本的广告banner * * @param visitor * @param adContext * @return */ private List&lt;FlightCompleteBannerImgItemDTO&gt; buildCustomizeAdBanners(VisitorInfo visitor, AdContext adContext) &#123; return customizeAdBannerService.transfer(visitor, adContext); &#125;&#125; 12345678910111213141516@Test public void getMarketCardsTest(final @Mocked VisitorInfo visitorInfo, final @Mocked MobileRequestHead head, final @Mocked AdContext adContext) throws Exception &#123; //录制方法的预期行为， new MockUp&lt;AdBannerRecommend&gt;() &#123; @Mock public List&lt;FlightMarketCardInformationType&gt; getResult(AdContext adContext) &#123; return new ArrayList&lt;&gt;(); &#125; &#125;; //这里要两个大括号 new Expectations() &#123;&#123; adContext.getqConfigManager(); result = null; &#125;&#125;; Assert.assertNotNull(adBannerRecommend.getMarketCards(visitorInfo, head, adContext)); &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"单元测试工具","slug":"单元测试工具","permalink":"http://yoursite.com/tags/单元测试工具/"}]},{"title":"夏天来了","slug":"夏天来了","date":"2018-07-08T09:42:45.000Z","updated":"2019-03-07T04:18:04.936Z","comments":true,"path":"2018/07/08/夏天来了/","link":"","permalink":"http://yoursite.com/2018/07/08/夏天来了/","excerpt":"这篇文章加密了","text":"Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-08T04:42:45.000Z","updated":"2019-03-07T02:50:10.230Z","comments":true,"path":"2018/07/08/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}