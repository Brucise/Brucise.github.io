---
title: jmockito
date: 2019-03-07 19:01:00
tags: [java,单元测试工具]
---
# 前言
最近换到了新组，增值-交叉BU，主要的业务就是机票完成页上售卖一些X产品，我是写服务端的，然后jenkins上单元测试覆盖率有点低，目前branch的覆盖率在百分之十四，而目标是在四月一号前达到百分之五十。所以最近接触的单测工具有点多，用过的几款有：powermock、mockito、jmockito。而powermock跟jenkins上的jacoco不兼容，mockito无法mock私有方法，jmokito成功提升了单测覆盖率。在这里总结一下jmockito的使用方法。
![覆盖率图](/images/jenkinscover.png "警察叔叔，就是这个人")
# 简介
[jmockito网站](http://jmockit.github.io/)
jmokito可以用来mock静态方法，类内部的私有方法、私有变量以及引用的其他类的方法。这里就不讲怎么引用maven包，直接上手用了。
# 几个概念
## CUT(code under test)
被测试代码
## mock和stub
mock是基于“行为”的测试，主要测试cut和被依赖着之间的相互调用；stub是基于“状态”的测试，主要测试CUT和被依赖者内部数据的状态。JMockit有两套API，mock API用来进行mock测试；mock-up API用来进行stub测试。
# API用法
## @Mocked
加上了JMockit的API @Mocked, JMockit会实例化这个对象
Mocked可以用来修饰类、接口和抽象类，返回默认值（如果是原始类型，返回原始值的默认值，如果为其他对象，则返回一个同样被Mocked的对象）
Mocked十分粗暴，会mock掉整个的实现
## @Injectable
@Injectable功能跟@Mocked相似，区别是@Injectable只针对修饰的实例，对mock类的静态方法、构造函数没有影响
## @Tested
@Tested表示被测试对象。如果该对象没有赋值，JMockit会去实例化它，若@Tested的构造函数有参数，则JMockit通过在测试属性&测试参数中查找@Injectable修饰的Mocked对象注入@Tested对象的构造函数来实例化，
不然，则用无参构造函数来实例化。除了构造函数的注入，JMockit还会通过属性查找的方式，把@Injectable对象注入到@Tested对象中。
注入的匹配规则：先类型，再名称(构造函数参数名，类的属性名)。若找到多个可以注入的@Injectable，则选择最优先定义的@Injectable对象
## @Capturing
@Capturing主要用于子类/实现类的Mock，比如java动态代理生成的类，这些类没有名字，无法进行正常的mock
当只知道父类或接口时，但需要控制其子类的行为时，子类可能有多个实现（可能有人工写的，也可能是AOP代理自动生成时），需要使用@Capturing
## Expectations
Record对象的核心方法，最核心和重要的注解了，可以和引用外部类的Mock对象(@Injectabe,@Mocked,@Capturing)来录制，也可以通过构建函数注入类/对象来录制
限制：不能mock对象的native方法和private方法
## MockUp & Mock
MockUp & @Mock提供更改代码行为的Mock方式，最强大mock实现，主要有以下限制：

1. 无法mock单个实例
2. 无法mock动态代理对象
3. 对类的所有方法都进行Mock，书写MockUp的代码量太大，可以用于项目中比较通用模块，减少大量重复的Exceptations

## Verifications
Verifications是用于做验证，过程式编程的福音，
验证Mock对象（即@Moked/@Injectable@Capturing修饰的或传入Expectation构造函数的对象)有没有调用过某方法，调用了多少次
主要用于一些没有返回值的代码验证

# 使用流程
	recoed(录制)-->replay(回放)-->verify(验证)
假设下面这个类是要测试的
``` java
package com.ctrip.flight.mobile.fio.core.xrecommend.card;

import com.alibaba.fastjson.JSON;
import com.ctrip.flight.mobile.fio.common.qconfig.factory.QConfigManager;
import com.ctrip.flight.mobile.fio.core.xrecommend.constant.CardExtraType;
import com.ctrip.flight.mobile.fio.core.xrecommend.context.AdContext;
import com.ctrip.flight.mobile.fio.core.xrecommend.service.adbannerservice.AdBannerModelTransfer;
import com.ctrip.flight.mobile.fio.core.xrecommend.service.adbannerservice.customize.CustomizeAdBannerService;
import com.ctrip.flight.mobile.fio.model.pojo.adbanner.FlightCompleteAdBannerConfigPojo;
import com.ctrip.flight.mobile.fio.model.pojo.adbanner.FlightCompleteBannerImgItemDTO;
import com.ctrip.flight.mobile.fio.model.pojo.visitorinfo.VisitorInfo;
import com.ctrip.model.flight.wireless.fio.ad.v1.entity.FlightMarketCardInformationType;
import com.ctrip.model.flight.wireless.fio.ad.v1.entity.FlightXProductExtendInformationType;
import com.ctriposs.baiji.rpc.mobile.common.types.MobileRequestHead;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service("AdBannerRecommend")
public class AdBannerRecommend extends AbstractRecommend {

    private AdBannerModelTransfer adBannerModelTransfer;
    private CustomizeAdBannerService customizeAdBannerService;
    private QConfigManager qConfigManager;

   
    @Autowired
    public AdBannerRecommend(AdBannerModelTransfer adBannerModelTransfer,
                             CustomizeAdBannerService customizeAdBannerService) {
        this.adBannerModelTransfer = adBannerModelTransfer;
        this.customizeAdBannerService = customizeAdBannerService;
    }

    @Override
    public List<FlightMarketCardInformationType> getMarketCards(VisitorInfo visitor, MobileRequestHead head,
                                                                AdContext adContext) {
        qConfigManager = adContext.getqConfigManager();
        return getResult(adContext);
    }

    public List<FlightMarketCardInformationType> getResult(AdContext adContext) {
        // 获得广告横幅卡片，productType=15
        List<FlightMarketCardInformationType> cards = new ArrayList<>();
        FlightMarketCardInformationType card = qConfigManager.getAdBannerCard();

        // 设置广告横幅的扩展信息，EXTRA_TYPE=18
        List<FlightXProductExtendInformationType> extas = new ArrayList<>();
        FlightXProductExtendInformationType exta = new FlightXProductExtendInformationType();
        exta.setExtentType(CardExtraType.EXTRA_TYPE_18);
        exta.setContent(buildCard(adContext));
        extas.add(exta);

        if (card != null) {
            card.setExtendInfo(extas);
            cards.add(card);
        }
        return cards;
    }

    private String buildCard(AdContext adContext) {
        // 从qconfig获得广告位配置，[]
        List<FlightCompleteAdBannerConfigPojo> banners = qConfigManager.getAdBanners();

        List<FlightCompleteBannerImgItemDTO> bs = adBannerModelTransfer.transfer(banners);
        // 添加所有的自定义广告banner
        bs.addAll(buildCustomizeAdBanners(adContext.getVisitorInfo(), adContext));
        return JSON.toJSONString(bs);
    }

    /**
     * 大配置版本的广告banner
     *
     * @param visitor
     * @param adContext
     * @return
     */
    private List<FlightCompleteBannerImgItemDTO> buildCustomizeAdBanners(VisitorInfo visitor, AdContext adContext) {
        return customizeAdBannerService.transfer(visitor, adContext);
    }

}
```
```java
 @Test
    public void getMarketCardsTest(final @Mocked VisitorInfo visitorInfo, final @Mocked MobileRequestHead head, final @Mocked AdContext adContext) throws Exception {
    //录制方法的预期行为，
        new MockUp<AdBannerRecommend>() {
            @Mock
            public List<FlightMarketCardInformationType> getResult(AdContext adContext) {
                return new ArrayList<>();
            }
        };
        //这里要两个大括号
        new Expectations() {{
            adContext.getqConfigManager();
            result = null;
        }};
        Assert.assertNotNull(adBannerRecommend.getMarketCards(visitorInfo, head, adContext));
    }
```